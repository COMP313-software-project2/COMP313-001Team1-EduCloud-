{"ast":null,"code":"/**\n * Machine id.\n *\n * Create a random 3-byte value (i.e. unique for this\n * process). Other drivers use a md5 of the machine id here, but\n * that would mean an asyc call to gethostname, so we don't bother.\n * @ignore\n */\nvar MACHINE_ID = parseInt(Math.random() * 0xffffff, 10); // Regular expression that checks for hex value\n\nvar checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$'); // Check if buffer exists\n\ntry {\n  if (Buffer && Buffer.from) var hasBufferType = true;\n} catch (err) {\n  hasBufferType = false;\n}\n/**\n * Create a new ObjectID instance\n *\n * @class\n * @param {(string|number)} id Can be a 24 byte hex string, 12 byte binary string or a Number.\n * @property {number} generationTime The generation time of this ObjectId instance\n * @return {ObjectID} instance of ObjectID.\n */\n\n\nvar ObjectID = function ObjectID(id) {\n  // Duck-typing to support ObjectId from different npm packages\n  if (id instanceof ObjectID) return id;\n  if (!(this instanceof ObjectID)) return new ObjectID(id);\n  this._bsontype = 'ObjectID'; // The most common usecase (blank id, new objectId instance)\n\n  if (id == null || typeof id === 'number') {\n    // Generate a new id\n    this.id = this.generate(id); // If we are caching the hex string\n\n    if (ObjectID.cacheHexString) this.__id = this.toString('hex'); // Return the object\n\n    return;\n  } // Check if the passed in id is valid\n\n\n  var valid = ObjectID.isValid(id); // Throw an error if it's not a valid setup\n\n  if (!valid && id != null) {\n    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');\n  } else if (valid && typeof id === 'string' && id.length === 24 && hasBufferType) {\n    return new ObjectID(new Buffer(id, 'hex'));\n  } else if (valid && typeof id === 'string' && id.length === 24) {\n    return ObjectID.createFromHexString(id);\n  } else if (id != null && id.length === 12) {\n    // assume 12 byte string\n    this.id = id;\n  } else if (id != null && id.toHexString) {\n    // Duck-typing to support ObjectId from different npm packages\n    return id;\n  } else {\n    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');\n  }\n\n  if (ObjectID.cacheHexString) this.__id = this.toString('hex');\n}; // Allow usage of ObjectId as well as ObjectID\n// var ObjectId = ObjectID;\n// Precomputed hex table enables speedy hex string conversion\n\n\nvar hexTable = [];\n\nfor (var i = 0; i < 256; i++) {\n  hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);\n}\n/**\n * Return the ObjectID id as a 24 byte hex string representation\n *\n * @method\n * @return {string} return the 24 byte hex string representation.\n */\n\n\nObjectID.prototype.toHexString = function () {\n  if (ObjectID.cacheHexString && this.__id) return this.__id;\n  var hexString = '';\n\n  if (!this.id || !this.id.length) {\n    throw new Error('invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' + JSON.stringify(this.id) + ']');\n  }\n\n  if (this.id instanceof _Buffer) {\n    hexString = convertToHex(this.id);\n    if (ObjectID.cacheHexString) this.__id = hexString;\n    return hexString;\n  }\n\n  for (var i = 0; i < this.id.length; i++) {\n    hexString += hexTable[this.id.charCodeAt(i)];\n  }\n\n  if (ObjectID.cacheHexString) this.__id = hexString;\n  return hexString;\n};\n/**\n * Update the ObjectID index used in generating new ObjectID's on the driver\n *\n * @method\n * @return {number} returns next index value.\n * @ignore\n */\n\n\nObjectID.prototype.get_inc = function () {\n  return ObjectID.index = (ObjectID.index + 1) % 0xffffff;\n};\n/**\n * Update the ObjectID index used in generating new ObjectID's on the driver\n *\n * @method\n * @return {number} returns next index value.\n * @ignore\n */\n\n\nObjectID.prototype.getInc = function () {\n  return this.get_inc();\n};\n/**\n * Generate a 12 byte id buffer used in ObjectID's\n *\n * @method\n * @param {number} [time] optional parameter allowing to pass in a second based timestamp.\n * @return {Buffer} return the 12 byte id buffer string.\n */\n\n\nObjectID.prototype.generate = function (time) {\n  if ('number' !== typeof time) {\n    time = ~~(Date.now() / 1000);\n  } // Use pid\n\n\n  var pid = (typeof process === 'undefined' || process.pid === 1 ? Math.floor(Math.random() * 100000) : process.pid) % 0xffff;\n  var inc = this.get_inc(); // Buffer used\n\n  var buffer = new Buffer(12); // Encode time\n\n  buffer[3] = time & 0xff;\n  buffer[2] = time >> 8 & 0xff;\n  buffer[1] = time >> 16 & 0xff;\n  buffer[0] = time >> 24 & 0xff; // Encode machine\n\n  buffer[6] = MACHINE_ID & 0xff;\n  buffer[5] = MACHINE_ID >> 8 & 0xff;\n  buffer[4] = MACHINE_ID >> 16 & 0xff; // Encode pid\n\n  buffer[8] = pid & 0xff;\n  buffer[7] = pid >> 8 & 0xff; // Encode index\n\n  buffer[11] = inc & 0xff;\n  buffer[10] = inc >> 8 & 0xff;\n  buffer[9] = inc >> 16 & 0xff; // Return the buffer\n\n  return buffer;\n};\n/**\n * Converts the id into a 24 byte hex string for printing\n *\n * @param {String} format The Buffer toString format parameter.\n * @return {String} return the 24 byte hex string representation.\n * @ignore\n */\n\n\nObjectID.prototype.toString = function (format) {\n  // Is the id a buffer then use the buffer toString method to return the format\n  if (this.id && this.id.copy) {\n    return this.id.toString(typeof format === 'string' ? format : 'hex');\n  } // if(this.buffer )\n\n\n  return this.toHexString();\n};\n/**\n * Converts to a string representation of this Id.\n *\n * @return {String} return the 24 byte hex string representation.\n * @ignore\n */\n\n\nObjectID.prototype.inspect = ObjectID.prototype.toString;\n/**\n * Converts to its JSON representation.\n *\n * @return {String} return the 24 byte hex string representation.\n * @ignore\n */\n\nObjectID.prototype.toJSON = function () {\n  return this.toHexString();\n};\n/**\n * Compares the equality of this ObjectID with `otherID`.\n *\n * @method\n * @param {object} otherID ObjectID instance to compare against.\n * @return {boolean} the result of comparing two ObjectID's\n */\n\n\nObjectID.prototype.equals = function equals(otherId) {\n  // var id;\n  if (otherId instanceof ObjectID) {\n    return this.toString() === otherId.toString();\n  } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 12 && this.id instanceof _Buffer) {\n    return otherId === this.id.toString('binary');\n  } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 24) {\n    return otherId.toLowerCase() === this.toHexString();\n  } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 12) {\n    return otherId === this.id;\n  } else if (otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) {\n    return otherId.toHexString() === this.toHexString();\n  } else {\n    return false;\n  }\n};\n/**\n * Returns the generation date (accurate up to the second) that this ID was generated.\n *\n * @method\n * @return {date} the generation date\n */\n\n\nObjectID.prototype.getTimestamp = function () {\n  var timestamp = new Date();\n  var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;\n  timestamp.setTime(Math.floor(time) * 1000);\n  return timestamp;\n};\n/**\n * @ignore\n */\n\n\nObjectID.index = ~~(Math.random() * 0xffffff);\n/**\n * @ignore\n */\n\nObjectID.createPk = function createPk() {\n  return new ObjectID();\n};\n/**\n * Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.\n *\n * @method\n * @param {number} time an integer number representing a number of seconds.\n * @return {ObjectID} return the created ObjectID\n */\n\n\nObjectID.createFromTime = function createFromTime(time) {\n  var buffer = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]); // Encode time into first 4 bytes\n\n  buffer[3] = time & 0xff;\n  buffer[2] = time >> 8 & 0xff;\n  buffer[1] = time >> 16 & 0xff;\n  buffer[0] = time >> 24 & 0xff; // Return the new objectId\n\n  return new ObjectID(buffer);\n}; // Lookup tables\n//var encodeLookup = '0123456789abcdef'.split('');\n\n\nvar decodeLookup = [];\ni = 0;\n\nwhile (i < 10) decodeLookup[0x30 + i] = i++;\n\nwhile (i < 16) decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++;\n\nvar _Buffer = Buffer;\n\nvar convertToHex = function (bytes) {\n  return bytes.toString('hex');\n};\n/**\n * Creates an ObjectID from a hex string representation of an ObjectID.\n *\n * @method\n * @param {string} hexString create a ObjectID from a passed in 24 byte hexstring.\n * @return {ObjectID} return the created ObjectID\n */\n\n\nObjectID.createFromHexString = function createFromHexString(string) {\n  // Throw an error if it's not a valid setup\n  if (typeof string === 'undefined' || string != null && string.length !== 24) {\n    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');\n  } // Use Buffer.from method if available\n\n\n  if (hasBufferType) return new ObjectID(new Buffer(string, 'hex')); // Calculate lengths\n\n  var array = new _Buffer(12);\n  var n = 0;\n  var i = 0;\n\n  while (i < 24) {\n    array[n++] = decodeLookup[string.charCodeAt(i++)] << 4 | decodeLookup[string.charCodeAt(i++)];\n  }\n\n  return new ObjectID(array);\n};\n/**\n * Checks if a value is a valid bson ObjectId\n *\n * @method\n * @return {boolean} return true if the value is a valid bson ObjectId, return false otherwise.\n */\n\n\nObjectID.isValid = function isValid(id) {\n  if (id == null) return false;\n\n  if (typeof id === 'number') {\n    return true;\n  }\n\n  if (typeof id === 'string') {\n    return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);\n  }\n\n  if (id instanceof ObjectID) {\n    return true;\n  }\n\n  if (id instanceof _Buffer) {\n    return true;\n  } // Duck-Typing detection of ObjectId like objects\n\n\n  if (id.toHexString) {\n    return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);\n  }\n\n  return false;\n};\n/**\n * @ignore\n */\n\n\nObject.defineProperty(ObjectID.prototype, 'generationTime', {\n  enumerable: true,\n  get: function () {\n    return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;\n  },\n  set: function (value) {\n    // Encode time into first 4 bytes\n    this.id[3] = value & 0xff;\n    this.id[2] = value >> 8 & 0xff;\n    this.id[1] = value >> 16 & 0xff;\n    this.id[0] = value >> 24 & 0xff;\n  }\n});\n/**\n * Expose.\n */\n\nmodule.exports = ObjectID;\nmodule.exports.ObjectID = ObjectID;\nmodule.exports.ObjectId = ObjectID;","map":{"version":3,"sources":["/Users/youngshinmin/Desktop/software-project/app/src/helpers/objectid.js"],"names":["MACHINE_ID","parseInt","Math","random","checkForHexRegExp","RegExp","Buffer","from","hasBufferType","err","ObjectID","id","_bsontype","generate","cacheHexString","__id","toString","valid","isValid","Error","length","createFromHexString","toHexString","hexTable","i","prototype","hexString","JSON","stringify","_Buffer","convertToHex","charCodeAt","get_inc","index","getInc","time","Date","now","pid","process","floor","inc","buffer","format","copy","inspect","toJSON","equals","otherId","toLowerCase","getTimestamp","timestamp","setTime","createPk","createFromTime","decodeLookup","bytes","string","array","n","test","Object","defineProperty","enumerable","get","set","value","module","exports","ObjectId"],"mappings":"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","sourcesContent":["/**\n * Machine id.\n *\n * Create a random 3-byte value (i.e. unique for this\n * process). Other drivers use a md5 of the machine id here, but\n * that would mean an asyc call to gethostname, so we don't bother.\n * @ignore\n */\nvar MACHINE_ID = parseInt(Math.random() * 0xffffff, 10);\n\n// Regular expression that checks for hex value\nvar checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');\n\n// Check if buffer exists\ntry {\n    if (Buffer && Buffer.from) var hasBufferType = true;\n} catch (err) {\n    hasBufferType = false;\n}\n\n/**\n * Create a new ObjectID instance\n *\n * @class\n * @param {(string|number)} id Can be a 24 byte hex string, 12 byte binary string or a Number.\n * @property {number} generationTime The generation time of this ObjectId instance\n * @return {ObjectID} instance of ObjectID.\n */\nvar ObjectID = function ObjectID(id) {\n    // Duck-typing to support ObjectId from different npm packages\n    if (id instanceof ObjectID) return id;\n    if (!(this instanceof ObjectID)) return new ObjectID(id);\n\n    this._bsontype = 'ObjectID';\n\n    // The most common usecase (blank id, new objectId instance)\n    if (id == null || typeof id === 'number') {\n        // Generate a new id\n        this.id = this.generate(id);\n        // If we are caching the hex string\n        if (ObjectID.cacheHexString) this.__id = this.toString('hex');\n        // Return the object\n        return;\n    }\n\n    // Check if the passed in id is valid\n    var valid = ObjectID.isValid(id);\n\n    // Throw an error if it's not a valid setup\n    if (!valid && id != null) {\n        throw new Error(\n            'Argument passed in must be a single String of 12 bytes or a string of 24 hex characters'\n        );\n    } else if (valid && typeof id === 'string' && id.length === 24 && hasBufferType) {\n        return new ObjectID(new Buffer(id, 'hex'));\n    } else if (valid && typeof id === 'string' && id.length === 24) {\n        return ObjectID.createFromHexString(id);\n    } else if (id != null && id.length === 12) {\n        // assume 12 byte string\n        this.id = id;\n    } else if (id != null && id.toHexString) {\n        // Duck-typing to support ObjectId from different npm packages\n        return id;\n    } else {\n        throw new Error(\n            'Argument passed in must be a single String of 12 bytes or a string of 24 hex characters'\n        );\n    }\n\n    if (ObjectID.cacheHexString) this.__id = this.toString('hex');\n};\n\n// Allow usage of ObjectId as well as ObjectID\n// var ObjectId = ObjectID;\n\n// Precomputed hex table enables speedy hex string conversion\nvar hexTable = [];\nfor (var i = 0; i < 256; i++) {\n    hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);\n}\n\n/**\n * Return the ObjectID id as a 24 byte hex string representation\n *\n * @method\n * @return {string} return the 24 byte hex string representation.\n */\nObjectID.prototype.toHexString = function() {\n    if (ObjectID.cacheHexString && this.__id) return this.__id;\n\n    var hexString = '';\n    if (!this.id || !this.id.length) {\n        throw new Error(\n            'invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' +\n            JSON.stringify(this.id) +\n            ']'\n        );\n    }\n\n    if (this.id instanceof _Buffer) {\n        hexString = convertToHex(this.id);\n        if (ObjectID.cacheHexString) this.__id = hexString;\n        return hexString;\n    }\n\n    for (var i = 0; i < this.id.length; i++) {\n        hexString += hexTable[this.id.charCodeAt(i)];\n    }\n\n    if (ObjectID.cacheHexString) this.__id = hexString;\n    return hexString;\n};\n\n/**\n * Update the ObjectID index used in generating new ObjectID's on the driver\n *\n * @method\n * @return {number} returns next index value.\n * @ignore\n */\nObjectID.prototype.get_inc = function() {\n    return (ObjectID.index = (ObjectID.index + 1) % 0xffffff);\n};\n\n/**\n * Update the ObjectID index used in generating new ObjectID's on the driver\n *\n * @method\n * @return {number} returns next index value.\n * @ignore\n */\nObjectID.prototype.getInc = function() {\n    return this.get_inc();\n};\n\n/**\n * Generate a 12 byte id buffer used in ObjectID's\n *\n * @method\n * @param {number} [time] optional parameter allowing to pass in a second based timestamp.\n * @return {Buffer} return the 12 byte id buffer string.\n */\nObjectID.prototype.generate = function(time) {\n    if ('number' !== typeof time) {\n        time = ~~(Date.now() / 1000);\n    }\n\n    // Use pid\n    var pid =\n        (typeof process === 'undefined' || process.pid === 1\n            ? Math.floor(Math.random() * 100000)\n            : process.pid) % 0xffff;\n    var inc = this.get_inc();\n    // Buffer used\n    var buffer = new Buffer(12);\n    // Encode time\n    buffer[3] = time & 0xff;\n    buffer[2] = (time >> 8) & 0xff;\n    buffer[1] = (time >> 16) & 0xff;\n    buffer[0] = (time >> 24) & 0xff;\n    // Encode machine\n    buffer[6] = MACHINE_ID & 0xff;\n    buffer[5] = (MACHINE_ID >> 8) & 0xff;\n    buffer[4] = (MACHINE_ID >> 16) & 0xff;\n    // Encode pid\n    buffer[8] = pid & 0xff;\n    buffer[7] = (pid >> 8) & 0xff;\n    // Encode index\n    buffer[11] = inc & 0xff;\n    buffer[10] = (inc >> 8) & 0xff;\n    buffer[9] = (inc >> 16) & 0xff;\n    // Return the buffer\n    return buffer;\n};\n\n/**\n * Converts the id into a 24 byte hex string for printing\n *\n * @param {String} format The Buffer toString format parameter.\n * @return {String} return the 24 byte hex string representation.\n * @ignore\n */\nObjectID.prototype.toString = function(format) {\n    // Is the id a buffer then use the buffer toString method to return the format\n    if (this.id && this.id.copy) {\n        return this.id.toString(typeof format === 'string' ? format : 'hex');\n    }\n\n    // if(this.buffer )\n    return this.toHexString();\n};\n\n/**\n * Converts to a string representation of this Id.\n *\n * @return {String} return the 24 byte hex string representation.\n * @ignore\n */\nObjectID.prototype.inspect = ObjectID.prototype.toString;\n\n/**\n * Converts to its JSON representation.\n *\n * @return {String} return the 24 byte hex string representation.\n * @ignore\n */\nObjectID.prototype.toJSON = function() {\n    return this.toHexString();\n};\n\n/**\n * Compares the equality of this ObjectID with `otherID`.\n *\n * @method\n * @param {object} otherID ObjectID instance to compare against.\n * @return {boolean} the result of comparing two ObjectID's\n */\nObjectID.prototype.equals = function equals(otherId) {\n    // var id;\n\n    if (otherId instanceof ObjectID) {\n        return this.toString() === otherId.toString();\n    } else if (\n        typeof otherId === 'string' &&\n        ObjectID.isValid(otherId) &&\n        otherId.length === 12 &&\n        this.id instanceof _Buffer\n    ) {\n        return otherId === this.id.toString('binary');\n    } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 24) {\n        return otherId.toLowerCase() === this.toHexString();\n    } else if (typeof otherId === 'string' && ObjectID.isValid(otherId) && otherId.length === 12) {\n        return otherId === this.id;\n    } else if (otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) {\n        return otherId.toHexString() === this.toHexString();\n    } else {\n        return false;\n    }\n};\n\n/**\n * Returns the generation date (accurate up to the second) that this ID was generated.\n *\n * @method\n * @return {date} the generation date\n */\nObjectID.prototype.getTimestamp = function() {\n    var timestamp = new Date();\n    var time = this.id[3] | (this.id[2] << 8) | (this.id[1] << 16) | (this.id[0] << 24);\n    timestamp.setTime(Math.floor(time) * 1000);\n    return timestamp;\n};\n\n/**\n * @ignore\n */\nObjectID.index = ~~(Math.random() * 0xffffff);\n\n/**\n * @ignore\n */\nObjectID.createPk = function createPk() {\n    return new ObjectID();\n};\n\n/**\n * Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.\n *\n * @method\n * @param {number} time an integer number representing a number of seconds.\n * @return {ObjectID} return the created ObjectID\n */\nObjectID.createFromTime = function createFromTime(time) {\n    var buffer = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    // Encode time into first 4 bytes\n    buffer[3] = time & 0xff;\n    buffer[2] = (time >> 8) & 0xff;\n    buffer[1] = (time >> 16) & 0xff;\n    buffer[0] = (time >> 24) & 0xff;\n    // Return the new objectId\n    return new ObjectID(buffer);\n};\n\n// Lookup tables\n//var encodeLookup = '0123456789abcdef'.split('');\nvar decodeLookup = [];\ni = 0;\nwhile (i < 10) decodeLookup[0x30 + i] = i++;\nwhile (i < 16) decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++;\n\nvar _Buffer = Buffer;\nvar convertToHex = function(bytes) {\n    return bytes.toString('hex');\n};\n\n/**\n * Creates an ObjectID from a hex string representation of an ObjectID.\n *\n * @method\n * @param {string} hexString create a ObjectID from a passed in 24 byte hexstring.\n * @return {ObjectID} return the created ObjectID\n */\nObjectID.createFromHexString = function createFromHexString(string) {\n    // Throw an error if it's not a valid setup\n    if (typeof string === 'undefined' || (string != null && string.length !== 24)) {\n        throw new Error(\n            'Argument passed in must be a single String of 12 bytes or a string of 24 hex characters'\n        );\n    }\n\n    // Use Buffer.from method if available\n    if (hasBufferType) return new ObjectID(new Buffer(string, 'hex'));\n\n    // Calculate lengths\n    var array = new _Buffer(12);\n    var n = 0;\n    var i = 0;\n\n    while (i < 24) {\n        array[n++] = (decodeLookup[string.charCodeAt(i++)] << 4) | decodeLookup[string.charCodeAt(i++)];\n    }\n\n    return new ObjectID(array);\n};\n\n/**\n * Checks if a value is a valid bson ObjectId\n *\n * @method\n * @return {boolean} return true if the value is a valid bson ObjectId, return false otherwise.\n */\nObjectID.isValid = function isValid(id) {\n    if (id == null) return false;\n\n    if (typeof id === 'number') {\n        return true;\n    }\n\n    if (typeof id === 'string') {\n        return id.length === 12 || (id.length === 24 && checkForHexRegExp.test(id));\n    }\n\n    if (id instanceof ObjectID) {\n        return true;\n    }\n\n    if (id instanceof _Buffer) {\n        return true;\n    }\n\n    // Duck-Typing detection of ObjectId like objects\n    if (id.toHexString) {\n        return id.id.length === 12 || (id.id.length === 24 && checkForHexRegExp.test(id.id));\n    }\n\n    return false;\n};\n\n/**\n * @ignore\n */\nObject.defineProperty(ObjectID.prototype, 'generationTime', {\n    enumerable: true,\n    get: function() {\n        return this.id[3] | (this.id[2] << 8) | (this.id[1] << 16) | (this.id[0] << 24);\n    },\n    set: function(value) {\n        // Encode time into first 4 bytes\n        this.id[3] = value & 0xff;\n        this.id[2] = (value >> 8) & 0xff;\n        this.id[1] = (value >> 16) & 0xff;\n        this.id[0] = (value >> 24) & 0xff;\n    }\n});\n\n/**\n * Expose.\n */\nmodule.exports = ObjectID;\nmodule.exports.ObjectID = ObjectID;\nmodule.exports.ObjectId = ObjectID;"]},"metadata":{},"sourceType":"module"}